- Respuesta[2]: rand_r crea un número entero aleatorio entre 0 y RAND_MAX, el cual después de eso es dividido entre 10, y aleatorio se iguala al resto para obtener un número entero entre 0 y 9. Este número se usa para hacer esperar a los hilos distintas cantidades de tiempo aleatorias (y que no sean demasiado prolongadas).

- Respuesta[3]: Si el hilo que ejecuta el main() no espera al resto, el resto no pueden finalizar, y solo se realizan las "salidas de los coches", pero nunca llegan a meta. Esto se debe a que en el momento que el hilo principal finaliza, el programa también lo hace, y por ende el resto de hilos no pueden terminar de ejecutar su código.

- Respuesta[4.1]: No es correcto, ya que si hacemos que según van terminando los hilos su ejecución, las llegadas estarán bien ordenadas, pero al ir esperando el hilo principal a todos los hilos en orden ascendente (1, 2, 3, 4...) a pesar de que todas las llegadas se ordenen bien, la clasificación siempre sería: Coche 1, cohe 2, coche 3, coche 4...

- Respuesta[4.2.c)]: Sí, puede dar lugar a errores, ya que al acceder a clasificaciónFinal[] y finalCarrera, si acceden varios hilos a la vez, pueden darse problemas al editarlos; es decir, es una zona crítica. Este problema se arregla haciendo uso de semáforos mutex, con las órdenes pthread_mutex_init(), pthread_mutex_lock(), pthread_mutex_unlock() y pthread_mutex_destroy(), que permiten que un solo hilo acceda a la zona crítica. Lo mismo sucede a la hora de modificar la variable global salida (que he añadido para coordinar las salidas). En cambio, con rand_r(), al cambiar la seed todo el rato no debería dar ningún problema.

- AÑADIDO ADICIONAL: He añadido una variable global llamada "salida", con el objetivo de coordinar la salida de todos los hilos, ya que me daba a veces el problema de que no habían salido todos los hilos y ya llegaba alguno a la meta. Además, como tienen que modificarla todos los hilos he controlado la zona crítica con un semáforo mutex.
